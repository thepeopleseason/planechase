<html>
<head>
<title>Eternities Map</title>
<link rel="stylesheet" href="planechase.css">
<link rel="stylesheet" href="https://code.jquery.com/ui/1.11.2/themes/smoothness/jquery-ui.css">
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">
<link rel="icon" href="images/favicon.ico" type="image/x-icon">
<script src="https://code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="https://code.jquery.com/ui/1.11.2/jquery-ui.js"></script>
<script src="planechase.js"></script>
<script type="text/javascript">
var init = 1;
var deck;

function get_point(index) {
  var point = index.split('_').map(function(el) { return parseInt(el, 10) });
  return point;
}

function get_distance(index) {
  var point = index.split('_');
  return Math.abs(point[0]) + Math.abs(point[1]);
}

function get_neighbors() {
  for (var x=0; x<eternity.cells.length; x++) {
    if (get_distance(eternity.cells[x]) == 1 &&
        typeof eternity.map[eternity.cells[x]] == 'undefined') {
      eternity.map[eternity.cells[x]] = deck.shift();
    }
  }
}

function pheno_done() {
  $('#phenomenon').hide();
  $('#plane_div').show();
}

function move(index) {
  var point1 = get_point(index);
  var updatemap = {}

  // hide chaos symbol on planeswalk
  $('#chaos').hide();

  // when Hellriding, generate a new plane
  if (Math.abs(point1[0]) == 1 && Math.abs(point1[1]) == 1) {
    // TODO: commented out to change to deck processing
    //       once deck finished, return to phenomena
    // var all = eternity.planes.concat(eternity.phenomena);

    newplane = deck.shift();

    // how to handle phenomena
    if (eternity.names[newplane].phenomenon) {
      var walkto = [];
      var phenomenon = newplane;

      // Interplanar Tunnel
      if (newplane == '226549.jpg') {
        // add 5 planes to choose from
        for (var x=0; x<5; x++) {
          walkto.push(deck.shift());
        }
      }
      // Spatial Merging (merge 2 planes)
      else if (newplane == '226546.jpg') {
        $('#phenomenon').html(
          '<a href="#" onclick="pheno_done();">' +
            `<img src="images/${ newplane }" height="450" title="${ phenomenon }"></a>`);
        walkto.push(deck.shift());
        walkto.push(deck.shift());

        updatemap['0_0'] = newplane;
      }
      else {
        $('#plane_div').hide();
        newplane = deck.shift();
      }

      var output = '';
      for (pl in walkto) {
        height = (walkto.length > 1) ? 40: 60;
        var img = `<img src="images/${ walkto[pl] }" height="${ height }%">`;
        if (walkto.indexOf('226549.jpg') >= 0) {
          output += `<a href="#" onclick="load('${ walkto[pl] }')">${ img }</a>`;
        }
        else {
          output += `<a href="#" onclick="roll();">${ img }</a>`;
        }
      }
      $('#phenomenon').html(output);
      $('#phenomenon').show();
    }
    updatemap['0_0'] = newplane;
  }

  // Reposition all existing planes in the map
  $.each(eternity.map, function(key, value) {
    if (typeof value != 'undefined') {
      var point2 = get_point(key);
      point2[0] -= point1[0];
      point2[1] -= point1[1];
      newindex = point2.join('_');

      // remove all planes greater than 3 hops away
      if (get_distance(newindex) < 4) {
        updatemap[newindex] = value;
      }
      else {
        // return removed planes back to the planar deck
        deck.push(value);
        shuffle_deck();
        // reset counters on recovery
        if (typeof eternity.names[value].counter != 'undefined') {
          eternity.names[value].counter = 0;
        }
      }
    }
  });

  // update the map, draw new neighbors
  eternity.map = updatemap;

  // clear current status
  $('#dice_button')[0].value = 'Roll Planar Die';

  get_neighbors();
  draw_map();
}

function draw_map() {
  for (var x=0; x<eternity.cells.length; x++) {
    $("#cell_"+eternity.cells[x]).html('');
    if (typeof eternity.map[eternity.cells[x]] != 'undefined') {
      link = get_link(eternity.map[eternity.cells[x]], eternity.cells[x]);
      $("#cell_"+eternity.cells[x]).html(link);
    }
    if (eternity.cells[x] == '0_0') {
      // write Planar Counters value
      var value;
      if (typeof eternity.names[eternity.map[eternity.cells[x]]].counter !=
          'undefined') {
        value = eternity.names[eternity.map[eternity.cells[x]]].counter;
      }
      else {
        value = '---';
      }
      $('#count_button')[0].value = value;
    }
  }

  // allow for hellriding
  if (!init) {
    $('#toolbar').show();
    for (var x in eternity.hellrides) {
      if (typeof eternity.map[eternity.hellrides[x]] == 'undefined') {
        $(`#cell_${ eternity.hellrides[x] }`).html(
          '<input type="button" value="Hellride" onclick="move(\''
            + eternity.hellrides[x] + '\');" class="myButton">');
      }
    }
  }
}

function get_link(plane, index) {
  var dist = get_distance(index);
  var img = `<img src="images/${ plane }" height="` +
      (window.innerHeight * 0.40) / (1 + (0.50 * dist)) +
      `" title="${ eternity.names[plane].name }:${ index }">`;

  var link = ''
  if (dist == 1) {
    link = `<a href="#" onclick="move('${ index }');">`;
  }
  else if (index == '0_0') {
    if (!init && eternity.names[plane].counter >= 0) {
      link = `<a href="#" onclick="add_counter('${ plane }');">`;
    }
    else {
      link = `<a href="#"${ init ? 'onclick="draw_map();"' : ''}>`;
    }
  }
  if (link) {
    return link.concat(img, '</a>');
  }
  else {
    return img;
  }
}

function get_help() {
  return 'An implementation of the Eternities Map variant of Magic The Gathering\'s Planescape, as described in <a href="https://magic.wizards.com/en/articles/archive/feature/eternities-map-2010-07-19-0">Gavin Duggan\'s Daily MTG article from 2010</a>.';
}

function init_deck() {
  deck = Array.from(eternity.planes.filter(function(pl) {
    return pl;
  }));
  shuffle_deck();
}

function shuffle_deck() {
  // shuffle the deck
  for (let i=deck.length-1; i>0; i--) {
    const j = Math.floor(Math.random()*i);
    const temp = deck[i]
    deck[i] = deck[j];
    deck[j] = temp;
  }
}

function add_counter(plane) {
  update_count('count_button', ++eternity.names[plane].counter);
}

$(document).ready(function () {
  $(document).keydown(function(event) {
    switch (event.which) {
    case 38:
    case 75:
    case 78:
      // N/Up Arrow/K - move up
      move('0_1');
      break;
    case 40:
    case 74:
    case 83:
      // S/Down Arrow/J - move down
      move('0_-1');
      break;
    case 39:
    case 69:
    case 76:
      // E/Right Arrow/L - move right
      move('1_0');
      break;
    case 37:
    case 72:
    case 87:
      // W/Left Arrow/I - move left
      move('-1_0');
      break;
    case 32:
      // SPACE: Reset planar die mana cost
      reset_cost();
      break;
    case 13:
    case 82:
      // R/ENTER: Roll planar die
      roll();
      break;
    case 67:
    case 107:
    case 187:
      // C/=/+: Add counter
      var plane = $("#cell_0_0 > a")
      if ((plane.size() == 1) && (/add_counter/.test(plane.prop('onclick').toString()))) {
        plane.prop('onclick')();
      }
      break;
    }
  });

  init_deck();
  eternity.map['0_0'] = deck.shift();

  draw_map();
  get_neighbors();
  init = 0;
});

</script>
</head>
<body style="text-align: center;">
<div id="toolbar" style="display: none">
<div style="float: left;">
    <input id="dice_button" type="button" value="Roll Planar Die"
           onclick="roll();" class="myButton">
    <div style="float: right; padding: 0 5px 0 5px;">Cost:
    <input type="button" id="cost_button" value="0" class="infobutton myButton" onclick="reset_cost()">
    </div>
</div>
<div style="float: left;">Planar Counters:
<input id="count_button" type="button" value="---" class="infoButton myButton" style="float: right;" disabled>
</div>
<div id="help"><a onclick="help();">What's This?</a></div>
</div>
<div id="phenomenon" style="display: none;"></div>
<div id="plane_div" style="margin: 10 auto;">
<table width="100%" height="100%">
<tr><td colspan="3"></td>
  <td class="plane inactive" id="cell_0_3">0_3</td>
  <td colspan="3"></td></tr>
<tr><td colspan="2"></td>
  <td class="plane inactive" id="cell_-1_2">-1_2</td>
  <td class="plane inactive" id="cell_0_2">0_2</td>
  <td class="plane inactive" id="cell_1_2">1_2</td>
  <td colspan="2"></td></tr>
<tr><td colspan="1"></td>
  <td class="plane inactive" id="cell_-2_1">-2_1</td>
  <td class="plane inactive" id="cell_-1_1">-1_1</td>
  <td class="plane inactive" id="cell_0_1">0_1</td>
  <td class="plane inactive" id="cell_1_1">1_1</td>
  <td class="plane inactive" id="cell_2_1">2_1</td>
  <td colspan="1"></td></tr>
<tr><td class="plane inactive" id="cell_-3_0">-3_0</td>
  <td class="plane inactive" id="cell_-2_0">-2_0</td>
  <td class="plane inactive" id="cell_-1_0">-1_0</td>
  <td class="plane current" id="cell_0_0">0_0</td>
  <td class="plane inactive" id="cell_1_0">1_0</td>
  <td class="plane inactive" id="cell_2_0">2_0</td>
  <td class="plane inactive" id="cell_3_0">3_0</td></tr>
<tr><td colspan="1"></td>
  <td class="plane inactive" id="cell_-2_-1">-2_-1</td>
  <td class="plane inactive" id="cell_-1_-1">-1_-1</td>
  <td class="plane inactive" id="cell_0_-1">0_-1</td>
  <td class="plane inactive" id="cell_1_-1">1_-1</td>
  <td class="plane inactive" id="cell_2_-1">2_-1</td>
  <td colspan="1"></td></tr>
<tr><td colspan="2"></td>
  <td class="plane inactive" id="cell_-1_-2">-1_-2</td>
  <td class="plane inactive" id="cell_0_-2">0_-2</td>
  <td class="plane inactive" id="cell_1_-2">1_-2</td>
  <td colspan="2"></td></tr>
<tr><td colspan="3"></td>
  <td class="plane inactive" id="cell_0_-3">0_-3</td>
  <td colspan="3"></td></tr>
</table>
</div>
</body>
</html>
